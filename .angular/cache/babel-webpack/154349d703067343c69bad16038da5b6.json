{"ast":null,"code":"/**\n * @license agm-direction\n * MIT license\n */\nimport { EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { GoogleMapsAPIWrapper } from '@agm/core';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@agm/core';\nlet AgmDirection = /*#__PURE__*/(() => {\n  class AgmDirection {\n    constructor(gmapsApi) {\n      this.gmapsApi = gmapsApi;\n      this.waypoints = [];\n      this.optimizeWaypoints = true;\n      this.provideRouteAlternatives = false;\n      this.avoidHighways = false;\n      this.avoidTolls = false;\n      this.avoidFerries = false; // Remove or draw direction\n\n      this.visible = true; // Direction change event handler\n\n      this.onChange = new EventEmitter(); // Direction response for the new request\n\n      this.onResponse = new EventEmitter(); // Send a custom infowindow\n\n      this.sendInfoWindow = new EventEmitter(); // Status of Directions Query (google.maps.DirectionsStatus.OVER_QUERY_LIMIT)\n\n      this.status = new EventEmitter(); // Marker drag event handler\n\n      this.originDrag = new EventEmitter();\n      this.destinationDrag = new EventEmitter();\n      this.waypointsMarker = []; // Use for visible flag\n\n      this.isFirstChange = true;\n    }\n\n    ngOnInit() {\n      if (this.visible === true) {\n        this.directionDraw();\n      }\n    }\n\n    ngOnChanges(obj) {\n      /**\n       * When visible is false then remove the direction layer\n       */\n      if (!this.visible) {\n        try {\n          this.removeMarkers();\n          this.removeDirections();\n        } catch (e) {}\n      } else {\n        if (this.isFirstChange) {\n          /**\n           * When visible is false at the first time\n           */\n          if (typeof this.directionsRenderer === 'undefined') {\n            this.directionDraw();\n          }\n\n          this.isFirstChange = false;\n          return;\n        }\n        /**\n         * When renderOptions are not first change then reset the display\n         */\n\n\n        if (typeof obj.renderOptions !== 'undefined') {\n          if (obj.renderOptions.firstChange === false) {\n            this.removeMarkers();\n            this.removeDirections();\n          }\n        }\n\n        this.directionDraw();\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyMarkers();\n      this.removeDirections();\n    }\n    /**\n     * This event is fired when the user creating or updating this direction\n     */\n\n\n    directionDraw() {\n      this.gmapsApi.getNativeMap().then(_map => {\n        const map = _map;\n\n        if (typeof this.directionsRenderer === 'undefined') {\n          this.directionsRenderer = new google.maps.DirectionsRenderer(this.renderOptions); // @ts-ignore\n\n          this.directionsRenderer.setMap(map);\n          this.directionsRenderer.addListener('directions_changed', () => {\n            this.onChange.emit(this.directionsRenderer.getDirections());\n          });\n        }\n\n        if (typeof this.directionsService === 'undefined') {\n          this.directionsService = new google.maps.DirectionsService();\n        }\n\n        if (typeof this.panel === 'undefined') {\n          // @ts-ignore\n          this.directionsRenderer.setPanel(null);\n        } else {\n          this.directionsRenderer.setPanel(this.panel);\n        } // Render exist direction\n\n\n        if (this.renderRoute) {\n          this.directionsRenderer.setDirections(this.renderRoute);\n          this.renderRoute = undefined;\n        } else {\n          // Request new direction\n          this.directionsService.route({\n            origin: this.origin,\n            destination: this.destination,\n            travelMode: this.travelMode || google.maps.TravelMode.DRIVING,\n            transitOptions: this.transitOptions,\n            drivingOptions: this.drivingOptions,\n            waypoints: this.waypoints,\n            optimizeWaypoints: this.optimizeWaypoints,\n            provideRouteAlternatives: this.provideRouteAlternatives,\n            avoidHighways: this.avoidHighways,\n            avoidTolls: this.avoidTolls,\n            avoidFerries: this.avoidFerries,\n            unitSystem: this.unitSystem\n          }, (response, status) => {\n            this.onResponse.emit(response); // Emit Query Status\n\n            this.status.emit(status);\n            /**\n             * DirectionsStatus\n             * https://developers.google.com/maps/documentation/javascript/directions#DirectionsStatus\n             */\n\n            switch (status) {\n              case google.maps.DirectionsStatus.OK:\n                this.directionsRenderer.setDirections(response);\n                /**\n                 * Emit The DirectionsResult Object\n                 * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults\n                 */\n                // Custom Markers\n\n                if (typeof this.markerOptions !== 'undefined') {\n                  this.destroyMarkers(); // Set custom markers\n\n                  const _route = response.routes[0].legs[0];\n\n                  try {\n                    // Origin Marker\n                    if (typeof this.markerOptions.origin !== 'undefined') {\n                      this.markerOptions.origin.map = map;\n                      this.markerOptions.origin.position = _route.start_location;\n                      this.originMarker = this.setMarker(map, this.originMarker, this.markerOptions.origin, _route.start_address);\n\n                      if (this.markerOptions.origin.draggable) {\n                        this.originMarker.addListener('dragend', () => {\n                          this.origin = this.originMarker.position;\n                          this.directionDraw();\n                          this.originDrag.emit(this.origin);\n                        });\n                      }\n                    } // Destination Marker\n\n\n                    if (typeof this.markerOptions.destination !== 'undefined') {\n                      this.markerOptions.destination.map = map;\n                      this.markerOptions.destination.position = _route.end_location;\n                      this.destinationMarker = this.setMarker(map, this.destinationMarker, this.markerOptions.destination, _route.end_address);\n\n                      if (this.markerOptions.destination.draggable) {\n                        this.destinationMarker.addListener('dragend', () => {\n                          this.destination = this.destinationMarker.position;\n                          this.directionDraw();\n                          this.destinationDrag.emit(this.destination);\n                        });\n                      }\n                    } // Waypoints Marker\n\n\n                    if (typeof this.markerOptions.waypoints !== 'undefined') {\n                      this.waypoints.forEach((waypoint, index) => {\n                        // If waypoints are not array then set all the same\n                        if (!Array.isArray(this.markerOptions.waypoints)) {\n                          this.markerOptions.waypoints.map = map;\n                          this.markerOptions.waypoints.position = _route.via_waypoints[index];\n                          this.waypointsMarker.push(this.setMarker(map, waypoint, this.markerOptions.waypoints, _route.via_waypoints[index]));\n                        } else {\n                          this.markerOptions.waypoints[index].map = map;\n                          this.markerOptions.waypoints[index].position = _route.via_waypoints[index];\n                          this.waypointsMarker.push(this.setMarker(map, waypoint, this.markerOptions.waypoints[index], _route.via_waypoints[index]));\n                        }\n                      }); // End forEach\n                    }\n                  } catch (err) {\n                    console.error('MarkerOptions error.', err);\n                  }\n                }\n\n                break;\n\n              case google.maps.DirectionsStatus.OVER_QUERY_LIMIT:\n                console.warn('The webpage has sent too many requests within the allowed time period.');\n                break;\n\n              default:\n                // console.warn(status);\n                break;\n            } // End switch\n\n          });\n        }\n      });\n    }\n    /**\n     * Custom Origin and Destination Icon\n     * @param map map\n     * @param marker marker\n     * @param markerOpts properties\n     * @param content marker's infowindow content\n     * @returns new marker\n     * @memberof AgmDirection\n     */\n\n\n    setMarker(map, marker, markerOpts, content) {\n      if (typeof this.infoWindow === 'undefined') {\n        this.infoWindow = new google.maps.InfoWindow();\n        this.sendInfoWindow.emit(this.infoWindow);\n      }\n\n      marker = new google.maps.Marker(markerOpts); // https://developers.google.com/maps/documentation/javascript/reference/marker?hl=zh-tw#MarkerOptions.clickable\n\n      if (marker.getClickable()) {\n        marker.addListener('click', () => {\n          const infowindoContent = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;\n          this.infoWindow.setContent(infowindoContent);\n          this.infoWindow.open(map, marker);\n        });\n      }\n\n      return marker;\n    }\n    /**\n     * This event is fired when remove markers\n     */\n\n\n    removeMarkers() {\n      if (typeof this.originMarker !== 'undefined') {\n        this.originMarker.setMap(null);\n      }\n\n      if (typeof this.destinationMarker !== 'undefined') {\n        this.destinationMarker.setMap(null);\n      }\n\n      this.waypointsMarker.forEach(w => {\n        if (typeof w !== 'undefined') {\n          w.setMap(null);\n        }\n      });\n    }\n    /**\n     * This event is fired when remove directions\n     */\n\n\n    removeDirections() {\n      if (this.directionsRenderer !== undefined) {\n        // @ts-ignore\n        this.directionsRenderer.setPanel(null);\n        this.directionsRenderer.setMap(null); // @ts-ignore\n\n        this.directionsRenderer = undefined;\n      }\n    }\n    /**\n     * This event is fired when destroy markers\n     */\n\n\n    destroyMarkers() {\n      // Remove origin markers\n      try {\n        if (typeof this.originMarker !== 'undefined') {\n          google.maps.event.clearListeners(this.originMarker, 'click');\n\n          if (this.markerOptions.origin.draggable) {\n            google.maps.event.clearListeners(this.originMarker, 'dragend');\n          }\n        }\n\n        if (typeof this.destinationMarker !== 'undefined') {\n          google.maps.event.clearListeners(this.destinationMarker, 'click');\n\n          if (this.markerOptions.origin.draggable) {\n            google.maps.event.clearListeners(this.destinationMarker, 'dragend');\n          }\n        }\n\n        this.waypointsMarker.forEach(w => {\n          if (typeof w !== 'undefined') {\n            google.maps.event.clearListeners(w, 'click');\n          }\n        });\n        this.removeMarkers();\n      } catch (err) {\n        console.error('Can not reset custom marker.', err);\n      }\n    }\n\n  }\n\n  AgmDirection.ɵfac = function AgmDirection_Factory(t) {\n    return new (t || AgmDirection)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.GoogleMapsAPIWrapper));\n  };\n\n  AgmDirection.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: AgmDirection,\n    selectors: [[\"agm-direction\"]],\n    inputs: {\n      waypoints: \"waypoints\",\n      optimizeWaypoints: \"optimizeWaypoints\",\n      provideRouteAlternatives: \"provideRouteAlternatives\",\n      avoidHighways: \"avoidHighways\",\n      avoidTolls: \"avoidTolls\",\n      avoidFerries: \"avoidFerries\",\n      visible: \"visible\",\n      renderRoute: \"renderRoute\",\n      origin: \"origin\",\n      destination: \"destination\",\n      infoWindow: \"infoWindow\",\n      travelMode: \"travelMode\",\n      transitOptions: \"transitOptions\",\n      drivingOptions: \"drivingOptions\",\n      unitSystem: \"unitSystem\",\n      renderOptions: \"renderOptions\",\n      panel: \"panel\",\n      markerOptions: \"markerOptions\"\n    },\n    outputs: {\n      onChange: \"onChange\",\n      onResponse: \"onResponse\",\n      sendInfoWindow: \"sendInfoWindow\",\n      status: \"status\",\n      originDrag: \"originDrag\",\n      destinationDrag: \"destinationDrag\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return AgmDirection;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AgmDirectionModule = /*#__PURE__*/(() => {\n  class AgmDirectionModule {\n    static forRoot() {\n      return {\n        ngModule: AgmDirectionModule\n      };\n    }\n\n    static forChild() {\n      return {\n        ngModule: AgmDirectionModule\n      };\n    }\n\n  }\n\n  AgmDirectionModule.ɵfac = function AgmDirectionModule_Factory(t) {\n    return new (t || AgmDirectionModule)();\n  };\n\n  AgmDirectionModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AgmDirectionModule\n  });\n  AgmDirectionModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return AgmDirectionModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AgmDirectionModule, {\n    declarations: [AgmDirection],\n    exports: [AgmDirection]\n  });\n})(); // Public classes.\n\n/**\n * Angular library starter\n * Build an Angular library compatible with AoT compilation & Tree shaking like an official package\n * Copyright Roberto Simonetti\n * MIT license\n * https://github.com/robisim74/angular-library-starter\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AgmDirection, AgmDirectionModule }; //# sourceMappingURL=agm-direction.js.map","map":null,"metadata":{},"sourceType":"module"}